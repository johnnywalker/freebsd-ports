diff --git mDNSPosix/Makefile.orig mDNSPosix/Makefile
index 9390f72..18c3dd0 100755
--- mDNSPosix/Makefile.orig
+++ mDNSPosix/Makefile
@@ -61,7 +61,7 @@ LD = ld -shared
 CP = cp
 RM = rm
 LN = ln -s -f
-CFLAGS_COMMON = -I$(COREDIR) -I$(SHAREDDIR) -I$(OBJDIR) -fwrapv -W -Wall -DPID_FILE=\"/var/run/mdnsd.pid\" -DMDNS_UDS_SERVERPATH=\"/var/run/mdnsd\"
+CFLAGS_COMMON = -ggdb -I$(COREDIR) -I$(SHAREDDIR) -I$(OBJDIR) -fwrapv -W -Wall -DPID_FILE=\"/var/run/mdnsd.pid\" -DMDNS_UDS_SERVERPATH=\"/var/run/mdnsd\"
 CFLAGS_PTHREAD =
 LINKOPTS =
 LINKOPTS_PTHREAD = -lpthread
diff --git mDNSPosix/mDNSPosix.c.orig mDNSPosix/mDNSPosix.c
index 45aa621..b2c03fb 100755
--- mDNSPosix/mDNSPosix.c.orig
+++ mDNSPosix/mDNSPosix.c
@@ -195,7 +195,7 @@ mDNSexport mStatus mDNSPlatformSendUDP(const mDNS *const m, const void *const ms
 	else if (err < 0)
 		{
 		static int MessageCount = 0;
-        // Don't report EHOSTDOWN (i.e. ARP failure), ENETDOWN, or no route to host for unicast destinations
+		// Don't report EHOSTDOWN (i.e. ARP failure), ENETDOWN, or no route to host for unicast destinations
 		if (!mDNSAddressIsAllDNSLinkGroup(dst))
 			if (errno == EHOSTDOWN || errno == ENETDOWN || errno == EHOSTUNREACH || errno == ENETUNREACH) return(mStatus_TransientErr);
 
@@ -313,78 +313,163 @@ mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int s
 			&senderAddr, senderPort, &destAddr, MulticastDNSPort, InterfaceID);
 	}
 
+  struct TCPSocket_struct {
+      TCPSocketFlags flags; /* Must come first, blah blah blah */
+      int fd;
+      struct sockaddr_in* sin;
+      mDNS const *m;
+  };
+  
 mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort * port)
 	{
-	(void)m;			// Unused
-	(void)flags;		// Unused
-	(void)port;			// Unused
-	return NULL;
+  	/* No way in hell I'm supporting TLS */
+  	assert(flags != kTCPSocketFlags_UseTLS);
+  
+  	int reuse_addr = 1;
+  	TCPSocket *t = malloc(sizeof(TCPSocket));
+  	mDNSPlatformMemZero(t, sizeof(TCPSocket));
+  	t->flags=flags;
+  	if ((t->fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
+  		{
+  		LogMsg("Error initializing socket %d (%s)", errno, strerror(errno));
+  		freeL("TCPSocket/mDNSPlatformTCPSocket", t);
+  		return (mDNSNULL);
+  		}
+  	t->m = m;
+  	struct sockaddr_in addr;
+  	mDNSPlatformMemZero(&addr, sizeof(addr));
+  	addr.sin_family = AF_INET;
+  	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+  	addr.sin_port = port->NotAnInteger;
+  	if (bind(t->fd, (struct sockaddr*) &addr, sizeof(addr)) < 0)
+  	    { LogMsg("ERROR: bind %s", strerror(errno)); }	
+  
+  	/* Let us rebind if necessary */
+  	setsockopt(t->fd, SOL_SOCKET, SO_REUSEADDR, &reuse_addr, sizeof(reuse_addr));
+  
+  	mDNSPlatformMemZero(&addr, sizeof(addr));
+  	socklen_t len = sizeof(addr);
+  	if (getsockname(t->fd, (struct sockaddr*) &addr, &len) < 0)
+  	    { LogMsg("getsockname - %s", strerror(errno)); }
+  
+  	port->NotAnInteger = addr.sin_port;
+  	return t;
 	}
 
 mDNSexport TCPSocket *mDNSPlatformTCPAccept(TCPSocketFlags flags, int sd)
 	{
 	(void)flags;		// Unused
-	(void)sd;			// Unused
-	return NULL;
+  	(void)sd;		// Unused
+  	LogMsg("Attempted to call unimplemented Accept function");
+  	return (mDNSNULL);
 	}
 
 mDNSexport int mDNSPlatformTCPGetFD(TCPSocket *sock)
 	{
-	(void)sock;			// Unused
-	return -1;
+  	assert(socket != NULL);
+  	return sock->fd;
 	}
 
 mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname, mDNSInterfaceID InterfaceID,
 										  TCPConnectionCallback callback, void *context)
 	{
-	(void)sock;			// Unused
-	(void)dst;			// Unused
-	(void)dstport;		// Unused
-	(void)hostname;     // Unused
-	(void)InterfaceID;	// Unused
-	(void)callback;		// Unused
-	(void)context;		// Unused
-	return(mStatus_UnsupportedErr);
+//	(void)hostname;     // Unused
+        /* see if this is getting used */
+        assert(!hostname);
+  	/* Don't implement callback semantics yet. POSIX >> whatever this is
+  	 */
+  	(void)InterfaceID;
+  	(void)callback;
+  	(void)context;
+  	fprintf(stderr, "Connecting to socket\n");
+  	sock->sin = (struct sockaddr_in*)(mallocL("sockaddr_in/mDNSPlatformTCPConnect", sizeof(struct sockaddr_in)));
+  	mDNSPlatformMemZero((char*)sock->sin, sizeof(struct sockaddr_in));
+  	sock->sin->sin_family = AF_INET;
+  	sock->sin->sin_port = dstport.NotAnInteger;
+  	sock->sin->sin_addr.s_addr = dst->ip.v4.NotAnInteger;
+  	if (connect(sock->fd, (struct sockaddr*)sock->sin, sizeof(struct sockaddr_in)) < 0)
+  	 	{
+  	 	LogMsg("ERROR: mDNSPlatformTCPConnect - connect failed: socket %d, error %d (%s)", sock->fd, errno, strerror(errno));;
+  	 	return errno;
+  		}
+  	return mStatus_NoError;
 	}
 
 mDNSexport void mDNSPlatformTCPCloseConnection(TCPSocket *sock)
 	{
-	(void)sock;			// Unused
+  	if (sock)
+  		{
+  		if(sock->fd != -1)
+  			{
+  			free(sock->sin);
+  			/* 2 == SHUT_RDRW */
+  			shutdown(sock->fd, 2);
+  			close(sock->fd);
+  			sock->fd = -1;
+  			}
+  		freeL("TCPSocket/mDNSPlatformTCPCloseConnection", sock);
+  		}
 	}
 
 mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)
 	{
-	(void)sock;			// Unused
-	(void)buf;			// Unused
-	(void)buflen;		// Unused
-	(void)closed;		// Unused
-	return 0;			
+  	/* We don't support TLS. */
+  	assert(!(sock->flags & kTCPSocketFlags_UseTLS));
+  
+  	*closed = mDNSfalse;
+  	int nread = recv(sock->fd, buf, buflen, 0);
+  	if (nread > 0)
+  		{
+  		}
+  	else if (nread == 0)
+  		{
+  		*closed = mDNStrue;
+  		}
+  	else if (errno == EAGAIN)
+  		{
+  		nread = 0;
+  		}
+  	else
+  		{
+  		fprintf(stderr, "ERROR READING %d (%s)\n", errno, strerror(errno));
+  		return -errno;
+  		}
+  	return nread;			
 	}
 
 mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)
 	{
-	(void)sock;			// Unused
-	(void)msg;			// Unused
-	(void)len;			// Unused
-	return 0;
+  	/* We don't support TLS. */
+  	assert(!(sock->flags & kTCPSocketFlags_UseTLS));
+  
+  	ssize_t nsent = send(sock->fd, msg, len, 0);
+  	if (nsent < 0)
+  		{
+  		if (errno == EAGAIN) nsent = 0;
+  		else { LogMsg("ERROR: mDNSPlatformWriteTCP - send %s", strerror(errno)); nsent = -1; }
+  		}
+  	return nsent;
 	}
 
 mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)
 	{
 	(void)m;			// Unused
 	(void)port;			// Unused
+  	/* Unimplemented because dnsextd doesn't use it */
 	return NULL;
 	}
 
 mDNSexport void           mDNSPlatformUDPClose(UDPSocket *sock)
 	{
 	(void)sock;			// Unused
+  	/* Unimplemented because dnsextd doesn't use it */
 	}
 	
 mDNSexport void mDNSPlatformUpdateProxyList(mDNS *const m, const mDNSInterfaceID InterfaceID)
 	{
 	(void)m;			// Unused
 	(void)InterfaceID;			// Unused
+  	/* Unimplemented because dnsextd doesn't use it */
 	}
 
 mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *const end, mDNSInterfaceID InterfaceID)
@@ -392,6 +477,7 @@ mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *c
 	(void)msg;			// Unused
 	(void)end;			// Unused
 	(void)InterfaceID;			// Unused
+	/* Unimplemented because dnsextd doesn't use it */
 	}
 	
 mDNSexport void mDNSPlatformSetLocalAddressCacheEntry(mDNS *const m, const mDNSAddr *const tpa, const mDNSEthAddr *const tha, mDNSInterfaceID InterfaceID)
@@ -400,15 +486,18 @@ mDNSexport void mDNSPlatformSetLocalAddressCacheEntry(mDNS *const m, const mDNSA
 	(void)tpa;			// Unused
 	(void)tha;			// Unused
 	(void)InterfaceID;			// Unused
+	/* Unimplemented because dnsextd doesn't use it */
 	}	
 
 mDNSexport mStatus mDNSPlatformTLSSetupCerts(void)
 	{
+	/* Unimplemented because dnsextd doesn't use it */
 	return(mStatus_UnsupportedErr);
 	}
 	
 mDNSexport void mDNSPlatformTLSTearDownCerts(void)
 	{
+	/* Unimplemented because dnsextd doesn't use it */
 	}
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -1585,3 +1674,5 @@ mStatus mDNSPosixRunEventLoopOnce(mDNS *m, const struct timeval *pTimeout,
 
 	return mStatus_NoError;
 	}
+
+/* vim: set noexpandtab sw=8 ts=8: */
diff --git mDNSShared/dnsextd.c.orig mDNSShared/dnsextd.c
index ecce4fc..3ad399c 100644
--- mDNSShared/dnsextd.c.orig
+++ mDNSShared/dnsextd.c
@@ -74,7 +74,9 @@ mDNSexport const char ProgramName[] = "dnsextd";
 #define EXPIRATION_INTERVAL			300					// check for expired records every 5 minutes
 #define SRV_TTL						7200				// TTL For _dns-update SRV records
 #define CONFIG_FILE					"/etc/dnsextd.conf"
-#define TCP_SOCKET_FLAGS   			kTCPSocketFlags_UseTLS
+//#define TCP_SOCKET_FLAGS   			kTCPSocketFlags_UseTLS
+#define	TCP_SOCKET_FLAGS			0 // FUCK TLS
+
 
 // LLQ Lease bounds (seconds)
 #define LLQ_MIN_LEASE (15 * 60)
@@ -767,7 +769,11 @@ mDNSlocal mDNSBool SuccessfulUpdateTransaction(PktMsg *request, PktMsg *reply)
 		{ vlogmsg = "Request opcode not an update"; goto failure; }
 
 	// check result
-	if ((reply->msg.h.flags.b[1] & kDNSFlag1_RC_Mask)) { vlogmsg = "Reply contains non-zero rcode";  goto failure; }
+	if ((reply->msg.h.flags.b[1] & kDNSFlag1_RC_Mask)) { 
+        fprintf(stderr, "Got error %d\n", reply->msg.h.flags.b[1]);
+        vlogmsg = "Reply contains non-zero rcode ";
+        goto failure;
+    }
 	if ((reply->msg.h.flags.b[0] & kDNSFlag0_QROP_Mask) != (kDNSFlag0_OP_Update | kDNSFlag0_QR_Response))
 		{ vlogmsg = "Reply opcode not an update response"; goto failure; }
 
@@ -1158,9 +1164,10 @@ SetupSockets
 	{
 	static const int kOn = 1;
 	int					sockpair[2];
-	mDNSBool			private = mDNSfalse;
-	struct sockaddr_in	daddr;
-	DNSZone			*	zone;
+        /* commented out since TLS is not supported */
+//	mDNSBool			private = mDNSfalse;
+//	struct sockaddr_in	daddr;
+//	DNSZone			*	zone;
 	mStatus				err = 0;
 	
 	// set up sockets on which we all ns requests
@@ -1176,6 +1183,7 @@ SetupSockets
 	err = bind( self->tcpsd, ( struct sockaddr* ) &self->addr, sizeof( self->addr ) );
 	require_action( !err, exit, LogErr( "SetupSockets", "bind self->tcpsd" ) );
 
+    fprintf(stderr, "Setting listen on socket %d\n", self->tcpsd);
 	err = listen( self->tcpsd, LISTENQ );
 	require_action( !err, exit, LogErr( "SetupSockets", "listen" ) );
 
@@ -1205,9 +1213,11 @@ SetupSockets
 	else
 		{
 		self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
+                fprintf(stderr, "Just got %d for llq_tcpsd\n", self->llq_tcpsd);
 		require_action( dnssd_SocketValid(self->llq_tcpsd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
 	
 #if defined(SO_REUSEADDR)
+    fprintf(stderr, "Setting listen on socket %d\n", self->llq_tcpsd);
 		err = setsockopt(self->llq_tcpsd, SOL_SOCKET, SO_REUSEADDR, &kOn, sizeof(kOn));
 		require_action( !err, exit, LogErr( "SetupSockets", "SO_REUSEADDR self->llq_tcpsd" ) );
 #endif
@@ -1238,6 +1248,15 @@ SetupSockets
 	self->LLQEventListenSock = sockpair[0];
 	self->LLQEventNotifySock = sockpair[1];
 
+    /* The rest of this function is retarded. It makes new sockets, and
+     * throws away the old ones it's listening on. That ends poorly (i.e.,
+     * in an infinte loop later.
+     *
+     * If you have private zones, this probably won't work at all. Sorry.
+     */
+
+    /* not using tls */
+/*
 	// set up socket on which we receive private requests
 
 	self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
@@ -1258,6 +1277,7 @@ SetupSockets
 	err = bind( self->tlssd, ( struct sockaddr* ) &daddr, sizeof( daddr ) );
 	require_action( !err, exit, LogErr( "SetupSockets", "bind self->tlssd" ) );
 
+    fprintf(stderr, "Setting listen on socket %d\n", self->tlssd);
 	err = listen( self->tlssd, LISTENQ );
 	require_action( !err, exit, LogErr( "SetupSockets", "listen" ) );
 
@@ -1278,6 +1298,7 @@ SetupSockets
 		require_action( !err, exit, LogErr( "SetupSockets", "mDNSPlatformTLSSetupCerts" ) );
 		}
 
+*/
 exit:
 
 	return err;
@@ -2816,7 +2837,13 @@ AcceptTCPConnection
 	require_action( context, exit, err = mStatus_NoMemoryErr; LogErr( "AcceptTCPConnection", "malloc" ) );
 	mDNSPlatformMemZero( context, sizeof( sizeof( TCPContext ) ) );
 	context->d		 = self;
+    fprintf(stderr, "Trying to accept on %d\n", sd);
 	newSock = accept( sd, ( struct sockaddr* ) &context->cliaddr, &clilen );
+    fprintf(stderr, "Just did an accept, got FD %d (passed in FD %d)\n", newSock, sd);
+    if (newSock < 0) {
+        fprintf(stderr, "Died, error=%d (%s)", errno, strerror(errno));
+        exit(1);
+    }
 	require_action( newSock != -1, exit, err = mStatus_UnknownErr; LogErr( "AcceptTCPConnection", "accept" ) );
 
 	context->sock = mDNSPlatformTCPAccept( flags, newSock );
@@ -2852,7 +2879,8 @@ mDNSlocal int Run(DaemonInfo *d)
 
 	if ( d->tcpsd + 1  > staticMaxFD )				staticMaxFD = d->tcpsd + 1;
 	if ( d->udpsd + 1  > staticMaxFD )				staticMaxFD = d->udpsd + 1;
-	if ( d->tlssd + 1  > staticMaxFD )				staticMaxFD = d->tlssd + 1;
+        /* not using tls */
+//	if ( d->tlssd + 1  > staticMaxFD )				staticMaxFD = d->tlssd + 1;
 	if ( d->llq_tcpsd + 1 > staticMaxFD )			staticMaxFD = d->llq_tcpsd + 1;
 	if ( d->llq_udpsd + 1 > staticMaxFD )			staticMaxFD = d->llq_udpsd + 1;
 	if ( d->LLQEventListenSock + 1 > staticMaxFD )	staticMaxFD = d->LLQEventListenSock + 1;
@@ -2884,7 +2912,8 @@ mDNSlocal int Run(DaemonInfo *d)
 		FD_ZERO(&rset);
 		FD_SET( d->tcpsd, &rset );
 		FD_SET( d->udpsd, &rset );
-		FD_SET( d->tlssd, &rset );
+                /* not using tls */
+//		FD_SET( d->tlssd, &rset );
 		FD_SET( d->llq_tcpsd, &rset );
 		FD_SET( d->llq_udpsd, &rset );
 		FD_SET( d->LLQEventListenSock, &rset );
@@ -2911,10 +2940,13 @@ mDNSlocal int Run(DaemonInfo *d)
 					// close sockets to prevent clients from making new requests during shutdown
 					close( d->tcpsd );
 					close( d->udpsd );
-					close( d->tlssd );
+                                        /* not using tls */
+//					close( d->tlssd );
 					close( d->llq_tcpsd );
 					close( d->llq_udpsd );
-					d->tcpsd = d->udpsd = d->tlssd = d->llq_tcpsd = d->llq_udpsd = -1;
+                                        /* not using tls */
+//					d->tcpsd = d->udpsd = d->tlssd = d->llq_tcpsd = d->llq_udpsd = -1;
+					d->tcpsd = d->udpsd = d->llq_tcpsd = d->llq_udpsd = -1;
 					DeleteRecords(d, mDNStrue);
 					return 0;
 					}
@@ -2959,7 +2991,8 @@ mDNSlocal int Run(DaemonInfo *d)
 			if (FD_ISSET(d->llq_udpsd, &rset))	RecvUDPMessage( d, d->llq_udpsd );
 			if (FD_ISSET(d->tcpsd, &rset))		AcceptTCPConnection( d, d->tcpsd, 0 );
 			if (FD_ISSET(d->llq_tcpsd, &rset))	AcceptTCPConnection( d, d->llq_tcpsd, 0 );
-			if (FD_ISSET(d->tlssd, &rset))  	AcceptTCPConnection( d, d->tlssd, TCP_SOCKET_FLAGS );
+                        /* not using tls */
+//			if (FD_ISSET(d->tlssd, &rset))  	AcceptTCPConnection( d, d->tlssd, TCP_SOCKET_FLAGS );
 			if (FD_ISSET(d->LLQEventListenSock, &rset))
 				{
 				// clear signalling data off socket
